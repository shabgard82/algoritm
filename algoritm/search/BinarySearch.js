function binarySearch(arr, target) {
  let firstIndex = 0;
  let endIndex = arr.length - 1;

  // تا زمانی که یک فضای جستجوی معتبر وجود دارد، حلقه ادامه پیدا می‌کند
  while (firstIndex <= endIndex) {
    // شاخص میانی فضای جستجوی فعلی را محاسبه می‌کنیم
    let midIndex = Math.floor((firstIndex + endIndex) / 2);

    // بررسی می‌کنیم که آیا مقدار جستجو برابر با مقدار در شاخص میانی است
    if (target === arr[midIndex]) {
      // اگر مقدار پیدا شود، شاخص را برمی‌گردانیم
      return midIndex;
    }

    // اگر مقدار جستجو کمتر از مقدار در شاخص میانی باشد،
    // مقدار باید در نیمه‌ی سمت چپ فضای جستجو باشد
    if (target < arr[midIndex]) {
      // به‌روزرسانی endIndex برای جستجو در نیمه‌ی چپ
      endIndex = midIndex - 1;
    } else {
      // در غیر این صورت، اگر مقدار جستجو بزرگتر از مقدار در شاخص میانی باشد،
      // مقدار باید در نیمه‌ی سمت راست فضای جستجو باشد
      // به‌روزرسانی firstIndex برای جستجو در نیمه‌ی راست
      firstIndex = midIndex + 1;
    }
  }

  // اگر از حلقه خارج شویم و مقدار جستجو پیدا نشده باشد، -1 را برمی‌گردانیم تا نشان دهد مقدار موجود نیست
  return -1;
}

// مثال‌هایی از استفاده از تابع جستجوی دودویی
console.log(binarySearch([1, 3, 5, 7, 9], 5)); // خروجی: 2 (شاخص مقدار 5)
console.log(binarySearch([1, 3, 5, 7, 9], 2)); // خروجی: -1 (مقدار پیدا نشد)
console.log(binarySearch([1, 3, 5, 7, 9], 8)); // خروجی: -1 (مقدار پیدا نشد)
//طبق الگو ها الگوریتم ورودی در هر مرحله به نصف کاهش پیدا میکند پس لگاریتمی هست
//Big O = O(Logn)